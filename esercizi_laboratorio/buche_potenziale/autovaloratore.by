""" -----------------------------------------------------
Classe per il calcolo degli autovalori e autovettori
----------------------------------------------------- """
import numpy as np

import conservatore
import potential_calculator

data = conservatore.data;
potentialClass = potential_calculator.potentialClass;
class Autovaloratore{

	def __init__(self){
		self.M = np.zeros( (data.par_numeroPunti-2, data.par_numeroPunti-2) );

		#l'equazione associta al problema presenta coefficienti costanti
		self.adix = -1;
#		self.bdix = 0;
		self.cdix = 0;

		#sono costanti anche gli elementi di matrice L,U
		self.Ldix = self.adix / data.par_larghezzaIntervallo**2 ;
		self.Ddix = 0;
		self.Udix = self.adix / data.par_larghezzaIntervallo**2 ;
		
	}#enddef
	

	def setD(self){
		dummy1 = 2 / data.par_larghezzaIntervallo**2
		self.Ddix = dummy1 + self.cdix;
	}#enddef


	def matrixBuilder(self, i){
	#considerando le notazioni utilizzate si screano non pochi problemi con gli indici
	#si passa da una matrice definita con indici che vanno da 1 a N 
	#per arrivare ad una che parte da 0 fino a n-2
		if( i == 1){
			self.M[0,0] = self.Ddix;
			self.M[0,1] = self.Udix;
		}
		if( i == data.par_numeroPunti-2){
			self.M[data.par_numeroPunti-3,data.par_numeroPunti-3] = self.Ddix;
			self.M[data.par_numeroPunti-3,data.par_numeroPunti-4] = self.Ldix;
		}
		self.M[i-2,i-2] = self.Ddix;
		self.M[i-2,i-1]   = self.Udix;
		self.M[i-2,i-3] = self.Ldix;
	}#enddef


	def autoCalculator(self){

		data.makeDictionaries();

		if( data.par_potentialSelector == "z"){

			potentialClass.calcZero();

			for l in range(data.par_lquanticoMax+1){
				for r in range(1, data.par_numeroPunti-1){
					self.cdix = data.potenzialeZero[r] + ( l*(l+1) / data.vettoreGriglia[r] );
					self.setD();
					self.matrixBuilder(r);	
				}
			aval, avec = np.linalg.eigh(self.M);
			data.ListdictAVzero[l]["autov"] = aval;
			data.ListdictAVzero[l]["autof"] = avec;
			}
			
		}
		if( data.par_potentialSelector == "c"){

			potentialClass.calcCoulomb();

			for l in range(data.par_lquanticoMax+1){
				for r in range(1, data.par_numeroPunti-1){
					self.cdix = data.potenzialeCoulomb[r] + ( l*(l+1) / data.vettoreGriglia[r] );
					self.setD();
					self.matrixBuilder(r);	
				}
			aval, avec = np.linalg.eigh(self.M);
			data.ListdictAVcoulomb[l]["autov"] = aval;
			data.ListdictAVcoulomb[l]["autof"] = avec;
			}
			
		}
		if( data.par_potentialSelector == "y"){

			potentialClass.calcYukawa();

			for l in range(data.par_lquanticoMax+1){
				for gamma in data.gammaY{
					for r in range(1, data.par_numeroPunti-1){
						self.cdix = data.dictPotenzialeYukawa[str(gamma)][r] + ( l*(l+1) / data.vettoreGriglia[r] );
						self.setD();
						self.matrixBuilder(r);	
					}
					aval, avec = np.linalg.eigh(self.M);
					dictKey = "autov" + str(gamma);
					data.ListdictAVyukawa[l][dictKey] = aval;
					dictKey = "autov" + str(gamma);
					data.ListdictAVyukawa[l][dictKey] = avec;										
				}
			}

		}
	}#enddef
	
	
}#endclass
